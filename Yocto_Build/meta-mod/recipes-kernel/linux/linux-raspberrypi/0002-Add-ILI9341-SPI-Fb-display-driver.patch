From a482e0517951f6eb8ecd1e2ca1c588163bf77d1e Mon Sep 17 00:00:00 2001
From: ManhLong79748 <long79748@gmail.com>
Date: Fri, 14 Nov 2025 16:01:26 +0700
Subject: [PATCH] Add ILI9341 SPI Fb display driver

---
 arch/arm/configs/bcm2711_defconfig        |   1 +
 drivers/video/fbdev/Kconfig               |   1 +
 drivers/video/fbdev/Makefile              |   1 +
 drivers/video/fbdev/ili9341_cus/Kconfig   |   5 +
 drivers/video/fbdev/ili9341_cus/Makefile  |   3 +
 drivers/video/fbdev/ili9341_cus/display.c | 143 ++++++++++++
 drivers/video/fbdev/ili9341_cus/display.h |  23 ++
 drivers/video/fbdev/ili9341_cus/ili9341.c | 267 ++++++++++++++++++++++
 drivers/video/fbdev/ili9341_cus/ili9341.h |  28 +++
 drivers/video/fbdev/ili9341_cus/memory.h  |  50 ++++
 10 files changed, 522 insertions(+)
 create mode 100644 drivers/video/fbdev/ili9341_cus/Kconfig
 create mode 100644 drivers/video/fbdev/ili9341_cus/Makefile
 create mode 100644 drivers/video/fbdev/ili9341_cus/display.c
 create mode 100644 drivers/video/fbdev/ili9341_cus/display.h
 create mode 100644 drivers/video/fbdev/ili9341_cus/ili9341.c
 create mode 100644 drivers/video/fbdev/ili9341_cus/ili9341.h
 create mode 100644 drivers/video/fbdev/ili9341_cus/memory.h

diff --git a/arch/arm/configs/bcm2711_defconfig b/arch/arm/configs/bcm2711_defconfig
index d9dc636eb222..31e596d34cf1 100644
--- a/arch/arm/configs/bcm2711_defconfig
+++ b/arch/arm/configs/bcm2711_defconfig
@@ -1524,3 +1524,4 @@ CONFIG_FUNCTION_PROFILER=y
 CONFIG_KGDB=y
 CONFIG_KGDB_KDB=y
 CONFIG_KDB_KEYBOARD=y
+CONFIG_FB_ILI9341=m
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index 11af544231a6..67cebc80d3d3 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2293,3 +2293,4 @@ config FB_RPISENSE
 source "drivers/video/fbdev/omap/Kconfig"
 source "drivers/video/fbdev/omap2/Kconfig"
 source "drivers/video/fbdev/mmp/Kconfig"
+source "drivers/video/fbdev/ili9341_cus/Kconfig"
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index 8d406d031c35..37f177bcea53 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -136,3 +136,4 @@ obj-$(CONFIG_FB_RPISENSE)	  += rpisense-fb.o
 
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
+obj-$(CONFIG_FB_ILI9341) 	  += ili9341_cus/
diff --git a/drivers/video/fbdev/ili9341_cus/Kconfig b/drivers/video/fbdev/ili9341_cus/Kconfig
new file mode 100644
index 000000000000..6d35eea2c04b
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/Kconfig
@@ -0,0 +1,5 @@
+config FB_ILI9341
+    tristate "ILI9341 TFT LCD Driver"
+    depends on FB && SPI
+    help
+      Say Y here if you want support for the ILI9341 SPI display driver.
diff --git a/drivers/video/fbdev/ili9341_cus/Makefile b/drivers/video/fbdev/ili9341_cus/Makefile
new file mode 100644
index 000000000000..a0b3ecca1e67
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/Makefile
@@ -0,0 +1,3 @@
+ccflags-y += -Wall
+obj-$(CONFIG_FB_ILI9341) += ili9341_cus.o
+ili9341_cus-y := ili9341.o display.o
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/display.c b/drivers/video/fbdev/ili9341_cus/display.c
new file mode 100644
index 000000000000..ffcb8d2e6f99
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/display.c
@@ -0,0 +1,143 @@
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+
+#include "display.h"
+#include "memory.h"
+
+#define ILI9341_DC_DATA             1
+#define ILI9341_DC_COMMAND          0
+
+static int ili9341_display_on(struct device_data *dev_data);
+static int ili9341_software_reset(struct device_data *dev_data);
+static int ili9341_send_command(struct device_data *dev_data, u8 *buff, size_t len);
+static int ili9341_send_command_with_args(struct device_data *dev_data, u8 cmd, u8 *args, size_t args_len);
+static int ili9341_send_data(struct device_data *dev_data, u8 *buff, size_t len);
+static int ili9341_send_display_buff_dma(struct device_data *dev_data);
+
+static const u8 display_init_sequence[] = {
+    1, ILI9341_PWCTR1, 0x23,
+    1, ILI9341_PWCTR2, 0x10,
+    2, ILI9341_VMCTR1, 0x3E, 0x28,
+    1, ILI9341_VMCTR2, 0x86,
+    1, ILI9341_MADCTL, 0x40, /* RGB */
+    1, ILI9341_VSCRSADD, 0x00,
+    1, ILI9341_PIXFMT, 0x66, /* 18 bits per pixel */
+    2, ILI9341_FRMCTR1, 0x00, 0x18,
+    3, ILI9341_DFUNCTR, 0x08, 0x82, 0x27,
+    0x00,
+};
+
+int ili9341_init(struct device_data *dev_data)
+{
+    int status;
+    u8 cmd_len;
+    const u8 *buff;
+
+    status = 0;
+    buff = display_init_sequence;
+
+    status = ili9341_software_reset(dev_data);
+    if (status)
+        return status;
+
+    /* break on 0 at the end of the array */
+    while (*buff)
+    {
+        cmd_len = *buff;
+        status = ili9341_send_command_with_args(dev_data, *(buff + 1), (u8 *)buff + 2, cmd_len);
+        if (status)
+            return status;
+        buff += (cmd_len + 2);
+    }
+    status = ili9341_display_on(dev_data);
+    return status;
+}
+
+int ili9341_send_display_buff(struct device_data *dev_data)
+{
+    int status;
+    u8 start_cmd;
+
+    status = 0;
+    start_cmd = 0x2C;
+    status = ili9341_send_command(dev_data, &start_cmd, 1);
+    if(status)
+        return status;
+    if(dev_data->dma_support)
+        status = ili9341_send_display_buff_dma(dev_data);
+    else
+        status = ili9341_send_data(dev_data, dev_data->display_buff, ILI9341_BUFFER_SIZE);
+    return status;
+}
+
+static int ili9341_display_on(struct device_data *dev_data)
+{
+    int i;
+    int status;
+    u8 on_sequence[] = {
+        ILI9341_SLPOUT,
+        ILI9341_DISPON,
+    };
+    status = 0;
+
+    for (i = 0; i < (sizeof(on_sequence) / sizeof(on_sequence[0])); i++)
+    {
+        status = ili9341_send_command(dev_data, &on_sequence[i], 1);
+        if (status)
+            return status;
+        msleep(150);
+    }
+    return status;
+}
+
+static int ili9341_software_reset(struct device_data *dev_data)
+{
+    int status;
+    u8 reset_cmd;
+
+    status = 0;
+    reset_cmd = ILI9341_SWRESET;
+    status = ili9341_send_command(dev_data, &reset_cmd, 1);
+    if (status)
+        return status;
+    msleep(150);
+    return status;
+}
+
+static int ili9341_send_command(struct device_data *dev_data, u8 *buff, size_t len)
+{
+    gpiod_set_value(dev_data->dc_gpio, ILI9341_DC_COMMAND);
+    return spi_write(dev_data->client, buff, len);
+}
+
+static int ili9341_send_command_with_args(struct device_data *dev_data, u8 cmd, u8 *args, size_t args_len)
+{
+    int status;
+    status = ili9341_send_command(dev_data, &cmd, 1);
+    if (status)
+        return status;
+    status = ili9341_send_data(dev_data, args, args_len);
+    return status;
+}
+
+static int ili9341_send_data(struct device_data *dev_data, u8 *buff, size_t len)
+{
+    gpiod_set_value(dev_data->dc_gpio, ILI9341_DC_DATA);
+    return spi_write(dev_data->client, buff, len);
+}
+
+static int ili9341_send_display_buff_dma(struct device_data *dev_data)
+{
+    struct spi_message buff_message;
+    struct spi_transfer buff_transfer;
+
+    spi_message_init(&buff_message);
+    buff_message.is_dma_mapped = 1;
+    buff_transfer.tx_buf = dev_data->display_buff;
+    buff_transfer.len = ILI9341_BUFFER_SIZE;
+    buff_transfer.tx_dma = dev_data->dma_display_buff;
+
+    spi_message_add_tail(&buff_transfer, &buff_message);
+    gpiod_set_value(dev_data->dc_gpio, ILI9341_DC_DATA);
+    return spi_sync(dev_data->client, &buff_message);
+}
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/display.h b/drivers/video/fbdev/ili9341_cus/display.h
new file mode 100644
index 000000000000..713a665452fd
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/display.h
@@ -0,0 +1,23 @@
+#ifndef _ILI9341_DISPLAY_H
+#define _ILI9341_DISPLAY_H
+
+#include <linux/types.h>
+
+#include "ili9341.h"
+
+#define ILI9341_HEIGHT              320
+#define ILI9341_WIDTH               240
+#define ILI9341_BYTES_PER_PIXEL     3
+#define ILI9341_BITS_PER_PIXEL      (8 * ILI9341_BYTES_PER_PIXEL)
+#define ILI9341_COLOR_LENGTH        6
+#define ILI9341_BUFFER_SIZE         (ILI9341_HEIGHT * ILI9341_WIDTH * ILI9341_BYTES_PER_PIXEL)
+#define ILI9341_LINE_LENGTH         (ILI9341_WIDTH * ILI9341_BYTES_PER_PIXEL)
+
+#define ILI9341_RED_OFFSET          18
+#define ILI9341_GREEN_OFFSET        10
+#define ILI9341_BLUE_OFFSET         2
+
+int ili9341_init(struct device_data *dev_data);
+int ili9341_send_display_buff(struct device_data *dev_data);
+
+#endif /* _ILI9341_DISPLAY_H */
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/ili9341.c b/drivers/video/fbdev/ili9341_cus/ili9341.c
new file mode 100644
index 000000000000..157822bf34aa
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/ili9341.c
@@ -0,0 +1,267 @@
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+
+#include "ili9341.h"
+#include "display.h"
+
+static int display_thread(void *data);
+static int ili9341_probe(struct spi_device *client);
+static int ili9341_remove(struct spi_device *client);
+static int ili9341_try_configure_dma(struct device_data *dev_data);
+static int ili9341_setcolreg(unsigned regno, unsigned red, unsigned green,
+                             unsigned blue, unsigned transp, struct fb_info *info);
+static int ili9341_check_var(struct fb_var_screeninfo *var, struct fb_info *info);
+static void ili9341_configure_fb(struct device_data *dev_data);
+
+static struct of_device_id ili9341_driver_of_ids[] = {
+    {
+        .compatible = "mr,custom_ili9341",
+    },
+    {/* NULL */},
+};
+MODULE_DEVICE_TABLE(of, ili9341_driver_of_ids);
+
+static struct spi_device_id ili9341_ids[] = {
+    {"custom_ili9341", 0},
+    {/* NULL */},
+};
+MODULE_DEVICE_TABLE(spi, ili9341_ids);
+
+static struct spi_driver ili9341_spi_driver = {
+    .probe = ili9341_probe,
+    .remove = ili9341_remove,
+    .driver = {
+        .name = "custom_ili9341",
+        .of_match_table = of_match_ptr(ili9341_driver_of_ids),
+    },
+};
+
+static struct fb_ops ili9341_fb_ops = {
+    .owner = THIS_MODULE,
+    .fb_check_var = ili9341_check_var,
+    .fb_setcolreg = ili9341_setcolreg,
+    .fb_fillrect = cfb_fillrect,
+    .fb_imageblit = cfb_imageblit,
+    .fb_copyarea = cfb_copyarea,
+};
+
+static int display_thread(void *data)
+{
+    struct device_data *dev_data;
+    dev_data = data;
+
+    while (!kthread_should_stop())
+    {
+        if (ili9341_send_display_buff(dev_data))
+            dev_err(&dev_data->client->dev, "error occured while sending data to the display");
+    }
+    return 0;
+}
+
+static int ili9341_probe(struct spi_device *client)
+{
+    int status;
+    struct device_data *dev_data;
+
+    if (!device_property_present(&client->dev, "dc-gpios"))
+    {
+        dev_err(&client->dev, "device tree property dc-gpios does not exist\n");
+        return -EINVAL;
+    }
+
+    dev_data = devm_kzalloc(&client->dev, sizeof(struct device_data), GFP_KERNEL);
+    if (!dev_data)
+        return -ENOMEM;
+
+    spi_set_drvdata(client, dev_data);
+    dev_data->client = client;
+
+    dev_data->display_buff = devm_kzalloc(&client->dev, ILI9341_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
+    if (!dev_data->display_buff)
+            return -ENOMEM;
+
+    if (ili9341_try_configure_dma(dev_data))
+    {
+        dev_data->dma_support = false;
+        dev_info(&client->dev, "DMA not supported\n");
+    }
+    else
+    {
+        dev_data->dma_support = true;
+        dev_info(&client->dev, "using DMA\n");
+    }
+
+    dev_data->dc_gpio = gpiod_get(&client->dev, "dc", GPIOD_OUT_HIGH);
+    if (IS_ERR(dev_data->dc_gpio))
+    {
+        dev_err(&client->dev, "could not setup dc gpio\n");
+        return PTR_ERR(dev_data->dc_gpio);
+    }
+
+    status = ili9341_init(dev_data);
+    if (status)
+    {
+        gpiod_put(dev_data->dc_gpio);
+        dev_err(&client->dev, "error while initialising display hardware\n");
+        return status;
+    }
+
+    dev_data->framebuffer_info = framebuffer_alloc(0, &client->dev);
+    if (dev_data->framebuffer_info == NULL)
+    {
+        gpiod_put(dev_data->dc_gpio);
+        return -ENOMEM;
+    }
+    if (fb_alloc_cmap(&dev_data->framebuffer_info->cmap, ILI9341_BITS_PER_PIXEL, 0))
+    {
+        gpiod_put(dev_data->dc_gpio);
+        framebuffer_release(dev_data->framebuffer_info);
+        return -ENOMEM;
+    }
+
+    ili9341_configure_fb(dev_data);
+
+    if (register_framebuffer(dev_data->framebuffer_info))
+    {
+        fb_dealloc_cmap(&dev_data->framebuffer_info->cmap);
+        framebuffer_release(dev_data->framebuffer_info);
+        gpiod_put(dev_data->dc_gpio);
+        dev_err(&client->dev, "error while registering framebuffer\n");
+        return -EINVAL;
+    }
+
+    dev_data->display_thread = kthread_create(display_thread, dev_data, "ili9341_kthread");
+    if (!dev_data->display_thread)
+    {
+        fb_dealloc_cmap(&dev_data->framebuffer_info->cmap);
+        framebuffer_release(dev_data->framebuffer_info);
+        gpiod_put(dev_data->dc_gpio);
+        return -ECHILD;
+    }
+
+    wake_up_process(dev_data->display_thread);
+    dev_info(&client->dev, "probe successful\n");
+    return 0;
+}
+
+static int ili9341_remove(struct spi_device *client)
+{
+    struct device_data *dev_data;
+    dev_data = spi_get_drvdata(client);
+
+    kthread_stop(dev_data->display_thread);
+    gpiod_put(dev_data->dc_gpio);
+    unregister_framebuffer(dev_data->framebuffer_info);
+    fb_dealloc_cmap(&dev_data->framebuffer_info->cmap);
+    framebuffer_release(dev_data->framebuffer_info);
+    if (dev_data->dma_support)
+        dma_unmap_single(dev_data->dma_dev, dev_data->dma_display_buff, ILI9341_BUFFER_SIZE, DMA_TO_DEVICE);
+    dev_info(&client->dev, "device removed\n");
+    return 0;
+}
+
+static int ili9341_try_configure_dma(struct device_data *dev_data)
+{
+    int status;
+    struct device *dev;
+    status = 0;
+    dev = dev_data->client->master->dev.parent;
+    dev_data->dma_dev = dev;
+
+    if (!dev->dma_mask)
+		return 0;
+
+    dev_data->dma_display_buff = dma_map_single(dev, dev_data->display_buff, ILI9341_BUFFER_SIZE, DMA_TO_DEVICE);
+    status = dma_mapping_error(dev, dev_data->dma_display_buff);
+    return status;
+}
+
+static int ili9341_setcolreg(unsigned regno, unsigned red, unsigned green,
+                             unsigned blue, unsigned transp, struct fb_info *info)
+{
+    if (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < ILI9341_PSEUDO_PALETTE_SIZE)
+    {
+        ((u32 *)(info->pseudo_palette))[regno] =
+            ((red & 0x3F) << ILI9341_RED_OFFSET) | ((green & 0x3F) << ILI9341_GREEN_OFFSET) | ((blue & 0x3F) << ILI9341_BLUE_OFFSET);
+        return 0;
+    }
+    return -EINVAL;
+}
+
+static int ili9341_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    var->xres = ILI9341_WIDTH;
+    var->yres = ILI9341_HEIGHT;
+    var->xres_virtual = ILI9341_WIDTH;
+    var->yres_virtual = ILI9341_HEIGHT;
+    var->bits_per_pixel = ILI9341_BITS_PER_PIXEL;
+    var->grayscale = 0;
+
+    var->red.offset = ILI9341_RED_OFFSET;
+    var->red.length = ILI9341_COLOR_LENGTH;
+    var->red.msb_right = 0;
+
+    var->green.offset = ILI9341_GREEN_OFFSET;
+    var->green.length = ILI9341_COLOR_LENGTH;
+    var->green.msb_right = 0;
+
+    var->blue.offset = ILI9341_BLUE_OFFSET;
+    var->blue.length = ILI9341_COLOR_LENGTH;
+    var->blue.msb_right = 0;
+
+    var->transp.offset = 0;
+    var->transp.length = 0;
+    var->transp.msb_right = 0;
+    return 0;
+}
+
+static void ili9341_configure_fb(struct device_data *dev_data)
+{
+    struct fb_info *info;
+
+    info = dev_data->framebuffer_info;
+    info->screen_base = dev_data->display_buff;
+    info->screen_size = ILI9341_BUFFER_SIZE;
+    info->fbops = &ili9341_fb_ops;
+    info->pseudo_palette = dev_data->pseudo_palette;
+
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.type = FB_TYPE_PACKED_PIXELS;
+    info->fix.line_length = ILI9341_LINE_LENGTH;
+    info->fix.accel = FB_ACCEL_NONE;
+    sprintf(info->fix.id, "CUST_ILI9341");
+
+    info->var.xres = ILI9341_WIDTH;
+    info->var.yres = ILI9341_HEIGHT;
+    info->var.xres_virtual = ILI9341_WIDTH;
+    info->var.yres_virtual = ILI9341_HEIGHT;
+    info->var.bits_per_pixel = ILI9341_BITS_PER_PIXEL;
+    info->var.grayscale = 0;
+    info->var.activate = FB_ACTIVATE_NOW;
+
+    info->var.red.offset = ILI9341_RED_OFFSET;
+    info->var.red.length = ILI9341_COLOR_LENGTH;
+    info->var.red.msb_right = 0;
+
+    info->var.green.offset = ILI9341_GREEN_OFFSET;
+    info->var.green.length = ILI9341_COLOR_LENGTH;
+    info->var.green.msb_right = 0;
+
+    info->var.blue.offset = ILI9341_BLUE_OFFSET;
+    info->var.blue.length = ILI9341_COLOR_LENGTH;
+    info->var.blue.msb_right = 0;
+
+    info->var.transp.offset = 0;
+    info->var.transp.length = 0;
+    info->var.transp.msb_right = 0;
+}
+
+module_spi_driver(ili9341_spi_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hanli");
+MODULE_DESCRIPTION("SPI driver for ILI9341 display");
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/ili9341.h b/drivers/video/fbdev/ili9341_cus/ili9341.h
new file mode 100644
index 000000000000..7d92fc633d93
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/ili9341.h
@@ -0,0 +1,28 @@
+#ifndef _ILI9341_H
+#define _ILI9341_H
+
+#include <linux/types.h>
+#include <linux/kthread.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio/consumer.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+
+#define ILI9341_PSEUDO_PALETTE_SIZE 16
+
+struct device_data
+{
+    struct spi_device *client;
+    struct task_struct *display_thread;
+    struct gpio_desc *dc_gpio;
+    u32 pseudo_palette[ILI9341_PSEUDO_PALETTE_SIZE];
+    u8 *display_buff;
+    struct fb_info *framebuffer_info;
+
+    /* underlying DMA-aware controller */
+	struct device *dma_dev;
+    dma_addr_t dma_display_buff;
+    bool dma_support;
+};
+
+#endif /* _ILI9341_H */
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/memory.h b/drivers/video/fbdev/ili9341_cus/memory.h
new file mode 100644
index 000000000000..591b6c1d90ff
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/memory.h
@@ -0,0 +1,50 @@
+#ifndef _ILI9341_MEMORY_H
+#define _ILI9341_MEMORY_H
+
+#define ILI9341_NOP           0x00
+#define ILI9341_SWRESET       0x01
+#define ILI9341_RDDID         0x04
+#define ILI9341_RDDST         0x09
+#define ILI9341_SLPIN         0x10
+#define ILI9341_SLPOUT        0x11
+#define ILI9341_PTLON         0x12
+#define ILI9341_NORON         0x13
+#define ILI9341_RDMODE        0x0A
+#define ILI9341_RDMADCTL      0x0B
+#define ILI9341_RDPIXFMT      0x0C
+#define ILI9341_RDIMGFMT      0x0D
+#define ILI9341_RDSELFDIAG    0x0F
+#define ILI9341_INVOFF        0x20
+#define ILI9341_INVON         0x21
+#define ILI9341_GAMMASET      0x26
+#define ILI9341_DISPOFF       0x28
+#define ILI9341_DISPON        0x29
+#define ILI9341_CASET         0x2A
+#define ILI9341_PASET         0x2B
+#define ILI9341_RAMWR         0x2C
+#define ILI9341_RAMRD         0x2E
+#define ILI9341_PTLAR         0x30
+#define ILI9341_VSCRDEF       0x33
+#define ILI9341_MADCTL        0x36
+#define ILI9341_VSCRSADD      0x37
+#define ILI9341_PIXFMT        0x3A
+#define ILI9341_FRMCTR1       0xB1
+#define ILI9341_FRMCTR2       0xB2
+#define ILI9341_FRMCTR3       0xB3
+#define ILI9341_INVCTR        0xB4
+#define ILI9341_DFUNCTR       0xB6
+#define ILI9341_PWCTR1        0xC0
+#define ILI9341_PWCTR2        0xC1
+#define ILI9341_PWCTR3        0xC2
+#define ILI9341_PWCTR4        0xC3
+#define ILI9341_PWCTR5        0xC4
+#define ILI9341_VMCTR1        0xC5
+#define ILI9341_VMCTR2        0xC7
+#define ILI9341_RDID1         0xDA
+#define ILI9341_RDID2         0xDB
+#define ILI9341_RDID3         0xDC
+#define ILI9341_RDID4         0xDD
+#define ILI9341_GMCTRP1       0xE0
+#define ILI9341_GMCTRN1       0xE1
+
+#endif /* _ILI9341_MEMORY_H */
\ No newline at end of file
-- 
2.34.1

