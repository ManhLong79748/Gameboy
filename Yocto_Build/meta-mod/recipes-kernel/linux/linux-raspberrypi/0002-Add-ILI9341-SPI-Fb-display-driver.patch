From c1724e91f21395ad4b3c51183a223d9fa64b6950 Mon Sep 17 00:00:00 2001
From: ManhLong79748 <long79748@gmail.com>
Date: Tue, 2 Dec 2025 09:18:42 +0700
Subject: [PATCH] Add ILI9341 SPI Fb display driver

---
 arch/arm/boot/dts/bcm2711-rpi-4-b.dts     |  25 ++
 arch/arm/configs/bcm2711_defconfig        |   2 +
 drivers/Kconfig                           |   2 +
 drivers/Makefile                          |   1 +
 drivers/mgpio/Kconfig                     |   6 +
 drivers/mgpio/Makefile                    |   2 +
 drivers/mgpio/mgpio.c                     | 143 ++++++++++++
 drivers/video/fbdev/Kconfig               |   1 +
 drivers/video/fbdev/Makefile              |   1 +
 drivers/video/fbdev/ili9341_cus/Kconfig   |   5 +
 drivers/video/fbdev/ili9341_cus/Makefile  |   3 +
 drivers/video/fbdev/ili9341_cus/display.c | 158 +++++++++++++
 drivers/video/fbdev/ili9341_cus/display.h |  25 ++
 drivers/video/fbdev/ili9341_cus/ili9341.c | 270 ++++++++++++++++++++++
 drivers/video/fbdev/ili9341_cus/ili9341.h |  28 +++
 drivers/video/fbdev/ili9341_cus/memory.h  |  50 ++++
 16 files changed, 722 insertions(+)
 create mode 100644 drivers/mgpio/Kconfig
 create mode 100644 drivers/mgpio/Makefile
 create mode 100644 drivers/mgpio/mgpio.c
 create mode 100644 drivers/video/fbdev/ili9341_cus/Kconfig
 create mode 100644 drivers/video/fbdev/ili9341_cus/Makefile
 create mode 100644 drivers/video/fbdev/ili9341_cus/display.c
 create mode 100644 drivers/video/fbdev/ili9341_cus/display.h
 create mode 100644 drivers/video/fbdev/ili9341_cus/ili9341.c
 create mode 100644 drivers/video/fbdev/ili9341_cus/ili9341.h
 create mode 100644 drivers/video/fbdev/ili9341_cus/memory.h

diff --git a/arch/arm/boot/dts/bcm2711-rpi-4-b.dts b/arch/arm/boot/dts/bcm2711-rpi-4-b.dts
index 50e632f04b3e..a518774cf48d 100644
--- a/arch/arm/boot/dts/bcm2711-rpi-4-b.dts
+++ b/arch/arm/boot/dts/bcm2711-rpi-4-b.dts
@@ -578,6 +578,31 @@
 	};
 };
 
+/* === Custom button === */
+&gpio {
+    button_pins: button_pins {
+        brcm,pins = <21 5 20 12 13 16>; /* GPIO21,5,20,12,13,16 */
+        brcm,function = <0 0 0 0 0 0>; /* 0 = input */
+        brcm,pull = <2 2 2 2 2 2>; /* 2 = pull-up */
+    };
+};
+
+/* add node platform device for driver */
+/{
+    gpio_buttons {
+        compatible = "gpio_base_myself";
+        pinctrl-names = "default";
+        pinctrl-0 = <&button_pins>;
+        button_up-gpios = <&gpio 21 GPIO_ACTIVE_LOW>;
+        button_down-gpios = <&gpio 5 GPIO_ACTIVE_LOW>;
+        button_left-gpios = <&gpio 20 GPIO_ACTIVE_LOW>;
+        button_right-gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
+        button_enter-gpios = <&gpio 13 GPIO_ACTIVE_LOW>;
+        button_esc-gpios = <&gpio 16 GPIO_ACTIVE_LOW>;
+        status = "okay";
+    };
+};
+
 / {
 	__overrides__ {
 		act_led_gpio = <&act_led>,"gpios:4";
diff --git a/arch/arm/configs/bcm2711_defconfig b/arch/arm/configs/bcm2711_defconfig
index d9dc636eb222..ac608db9e1ba 100644
--- a/arch/arm/configs/bcm2711_defconfig
+++ b/arch/arm/configs/bcm2711_defconfig
@@ -1524,3 +1524,5 @@ CONFIG_FUNCTION_PROFILER=y
 CONFIG_KGDB=y
 CONFIG_KGDB_KDB=y
 CONFIG_KDB_KEYBOARD=y
+CONFIG_FB_ILI9341=m
+CONFIG_MGPIO_BUTTON=m
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 8befa53f43be..21e4ad145965 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -228,4 +228,6 @@ source "drivers/interconnect/Kconfig"
 
 source "drivers/counter/Kconfig"
 
+source "drivers/mgpio/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index aaef17cc6512..270b032e44fd 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -186,3 +186,4 @@ obj-$(CONFIG_SIOX)		+= siox/
 obj-$(CONFIG_GNSS)		+= gnss/
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
+obj-$(CONFIG_MGPIO_BUTTON) += mgpio/
diff --git a/drivers/mgpio/Kconfig b/drivers/mgpio/Kconfig
new file mode 100644
index 000000000000..68b3bb782d2b
--- /dev/null
+++ b/drivers/mgpio/Kconfig
@@ -0,0 +1,6 @@
+# drivers/mgpio/Kconfig
+config MGPIO_BUTTON
+    tristate "Raspberry Pi GPIO Button Driver"
+    depends on INPUT && GPIOLIB && OF
+    help
+      Say Y here to enable support for GPIO-based buttons on Raspberry Pi as input devices.
\ No newline at end of file
diff --git a/drivers/mgpio/Makefile b/drivers/mgpio/Makefile
new file mode 100644
index 000000000000..9aed32544a69
--- /dev/null
+++ b/drivers/mgpio/Makefile
@@ -0,0 +1,2 @@
+# drivers/mgpio/Makefile
+obj-$(CONFIG_MGPIO_BUTTON) += mgpio.o
\ No newline at end of file
diff --git a/drivers/mgpio/mgpio.c b/drivers/mgpio/mgpio.c
new file mode 100644
index 000000000000..87667febd260
--- /dev/null
+++ b/drivers/mgpio/mgpio.c
@@ -0,0 +1,143 @@
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/jiffies.h>
+
+#define DRIVER_AUTHOR "long79748@gmail.com"
+#define DRIVER_DESC   "Button driver using interrupt as input device"
+
+struct button_data {
+    struct gpio_desc *gpiod;
+    int irq;
+    unsigned int keycode;
+    struct input_dev *input;
+    unsigned long last_time; // Track thời gian debounce
+    unsigned int debounce;   // Debounce interval (ms) - SỬA: Thêm field này
+};
+
+static struct button_data buttons[6];
+
+static const struct of_device_id gpiod_dt_ids[] = {
+    { .compatible = "gpio_base_myself", },
+    { /* sentinel */ }
+};
+
+static irqreturn_t button_handler(int irq, void *dev_id) {
+    struct button_data *btn = dev_id;
+    unsigned long now = jiffies;
+    
+    if (time_before(now, btn->last_time + msecs_to_jiffies(btn->debounce))) {
+        return IRQ_HANDLED; // Ignore bounce/noise
+    }
+    btn->last_time = now;
+
+    int value = gpiod_get_value(btn->gpiod);
+    // SỬA: Thêm debug raw value để check logic
+    pr_info("Raw GPIO value: %d\n", value);
+    int pressed = !value; // ACTIVE_LOW: low=pressed
+    pr_info("Button %d %s\n", btn->keycode, pressed ? "Pressed" : "Released");
+    input_report_key(btn->input, btn->keycode, pressed);
+    input_sync(btn->input);
+    return IRQ_HANDLED;
+}
+
+static int my_pdrv_probe(struct platform_device *pdev) {
+    struct device *dev = &pdev->dev;
+    struct input_dev *input;
+    int i, ret;
+    u32 debounce_ms = 200; // Default 200ms
+    // SỬA: Parse debounce-interval từ DT (ms), fallback default nếu không có
+    of_property_read_u32(dev->of_node, "debounce-interval", &debounce_ms);
+
+    // Create input device
+    input = devm_input_allocate_device(dev);
+    if (!input) return -ENOMEM;
+    input->name = "RPi Buttons";
+    input->phys = "gpio-buttons/input0";
+    input->id.bustype = BUS_HOST;
+    input->id.vendor = 0x0001;
+    input->id.product = 0x0001;
+    input->id.version = 0x0100;
+    // SỬA: Set parent cho input device
+    input->dev.parent = dev;
+    set_bit(EV_KEY, input->evbit); // Support key events
+
+    // Map buttons: up=GPIO4, down=5, left=6, right=12, enter=13, esc=16
+    const char *btn_names[6] = {"button_up", "button_down", "button_left", "button_right", "button_enter", "button_esc"};
+    unsigned int keycodes[6] = {KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_ENTER, KEY_ESC};
+
+    for (i = 0; i < 6; i++) {
+        buttons[i].gpiod = gpiod_get(dev, btn_names[i], GPIOD_IN);
+        if (IS_ERR(buttons[i].gpiod)) {
+            ret = PTR_ERR(buttons[i].gpiod);
+            goto err_cleanup;
+        }
+        // SỬA: Xóa gpiod_set_debounce (không hiệu quả), dùng manual thay thế
+        // gpiod_set_debounce(buttons[i].gpiod, debounce_ms * 1000); // Bỏ
+
+        buttons[i].irq = gpiod_to_irq(buttons[i].gpiod);
+        buttons[i].keycode = keycodes[i];
+        buttons[i].input = input;
+        buttons[i].debounce = debounce_ms; // SỬA: Lưu debounce per button
+        buttons[i].last_time = 0; // Init debounce time
+
+        set_bit(keycodes[i], input->keybit); // Enable keycode
+
+        // SỬA: Thay flags thành RISING + FALLING để detect cả pressed/released
+        ret = request_irq(buttons[i].irq, button_handler, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_SHARED,
+                          "button_irq", &buttons[i]);
+        if (ret) {
+            gpiod_put(buttons[i].gpiod);
+            goto err_cleanup;
+        }
+    }
+
+    ret = input_register_device(input);
+    if (ret) goto err_cleanup;
+
+    platform_set_drvdata(pdev, input);
+    pr_info("Probe successful\n");
+    return 0;
+
+err_cleanup: // SỬA: Thêm error handling - cleanup các buttons trước đó
+    while (--i >= 0) {
+        free_irq(buttons[i].irq, &buttons[i]);
+        gpiod_put(buttons[i].gpiod);
+    }
+    return ret;
+}
+
+static int my_pdrv_remove(struct platform_device *pdev) {
+    struct input_dev *input = platform_get_drvdata(pdev);
+    int i;
+
+    for (i = 0; i < 6; i++) {
+        free_irq(buttons[i].irq, &buttons[i]);
+        gpiod_put(buttons[i].gpiod);
+    }
+
+    input_unregister_device(input);
+    pr_info("Remove successful\n");
+    return 0;
+}
+
+static struct platform_driver mypdrv = {
+    .probe = my_pdrv_probe,
+    .remove = my_pdrv_remove,
+    .driver = {
+        .name = "descriptor-based",
+        .of_match_table = of_match_ptr(gpiod_dt_ids),
+        .owner = THIS_MODULE,
+    },
+};
+
+module_platform_driver(mypdrv);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION("1.0");
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index 11af544231a6..67cebc80d3d3 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2293,3 +2293,4 @@ config FB_RPISENSE
 source "drivers/video/fbdev/omap/Kconfig"
 source "drivers/video/fbdev/omap2/Kconfig"
 source "drivers/video/fbdev/mmp/Kconfig"
+source "drivers/video/fbdev/ili9341_cus/Kconfig"
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index 8d406d031c35..37f177bcea53 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -136,3 +136,4 @@ obj-$(CONFIG_FB_RPISENSE)	  += rpisense-fb.o
 
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
+obj-$(CONFIG_FB_ILI9341) 	  += ili9341_cus/
diff --git a/drivers/video/fbdev/ili9341_cus/Kconfig b/drivers/video/fbdev/ili9341_cus/Kconfig
new file mode 100644
index 000000000000..6d35eea2c04b
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/Kconfig
@@ -0,0 +1,5 @@
+config FB_ILI9341
+    tristate "ILI9341 TFT LCD Driver"
+    depends on FB && SPI
+    help
+      Say Y here if you want support for the ILI9341 SPI display driver.
diff --git a/drivers/video/fbdev/ili9341_cus/Makefile b/drivers/video/fbdev/ili9341_cus/Makefile
new file mode 100644
index 000000000000..a0b3ecca1e67
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/Makefile
@@ -0,0 +1,3 @@
+ccflags-y += -Wall
+obj-$(CONFIG_FB_ILI9341) += ili9341_cus.o
+ili9341_cus-y := ili9341.o display.o
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/display.c b/drivers/video/fbdev/ili9341_cus/display.c
new file mode 100644
index 000000000000..b0ecc5fb949f
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/display.c
@@ -0,0 +1,158 @@
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+
+#include "display.h"
+#include "memory.h"
+
+#define ILI9341_DC_DATA             1
+#define ILI9341_DC_COMMAND          0
+
+static int ili9341_display_on(struct device_data *dev_data);
+static int ili9341_software_reset(struct device_data *dev_data);
+static int ili9341_send_command(struct device_data *dev_data, u8 *buff, size_t len);
+static int ili9341_send_command_with_args(struct device_data *dev_data, u8 cmd, u8 *args, size_t args_len);
+static int ili9341_send_data(struct device_data *dev_data, u8 *buff, size_t len);
+static int ili9341_send_display_buff_dma(struct device_data *dev_data);
+
+static const u8 display_init_sequence[] = {
+    1, ILI9341_PWCTR1, 0x23,
+    1, ILI9341_PWCTR2, 0x10,
+    2, ILI9341_VMCTR1, 0x3E, 0x28,
+    1, ILI9341_VMCTR2, 0x86,
+    1, ILI9341_MADCTL, 0xE0, /* RGB, landscape (MV=1, MY=1) */
+    1, ILI9341_VSCRSADD, 0x00,
+    1, ILI9341_PIXFMT, 0x55, /* 16 bits per pixel (RGB565) */
+    2, ILI9341_FRMCTR1, 0x00, 0x18,
+    3, ILI9341_DFUNCTR, 0x08, 0x82, 0x27,
+    0x00,
+};
+
+int ili9341_init(struct device_data *dev_data)
+{
+    int status;
+    u8 cmd_len;
+    const u8 *buff;
+
+    status = 0;
+    buff = display_init_sequence;
+
+    status = ili9341_software_reset(dev_data);
+    if (status)
+        return status;
+
+    /* break on 0 at the end of the array */
+    while (*buff)
+    {
+        cmd_len = *buff;
+        status = ili9341_send_command_with_args(dev_data, *(buff + 1), (u8 *)buff + 2, cmd_len);
+        if (status)
+            return status;
+        buff += (cmd_len + 2);
+    }
+    // status = ili9341_set_window(dev_data);
+    // if (status) return status;
+    status = ili9341_display_on(dev_data);
+    return status;
+}
+
+int ili9341_send_display_buff(struct device_data *dev_data)
+{
+    int status;
+    u8 start_cmd;
+
+    status = 0;
+    start_cmd = 0x2C;
+    status = ili9341_send_command(dev_data, &start_cmd, 1);
+    if(status)
+        return status;
+    if(dev_data->dma_support)
+        status = ili9341_send_display_buff_dma(dev_data);
+    else
+        status = ili9341_send_data(dev_data, dev_data->display_buff, ILI9341_BUFFER_SIZE);
+    return status;
+}
+
+static int ili9341_display_on(struct device_data *dev_data)
+{
+    int i;
+    int status;
+    u8 on_sequence[] = {
+        ILI9341_SLPOUT,
+        ILI9341_DISPON,
+    };
+    status = 0;
+
+    for (i = 0; i < (sizeof(on_sequence) / sizeof(on_sequence[0])); i++)
+    {
+        status = ili9341_send_command(dev_data, &on_sequence[i], 1);
+        if (status)
+            return status;
+        msleep(150);
+    }
+    return status;
+}
+
+static int ili9341_software_reset(struct device_data *dev_data)
+{
+    int status;
+    u8 reset_cmd;
+
+    status = 0;
+    reset_cmd = ILI9341_SWRESET;
+    status = ili9341_send_command(dev_data, &reset_cmd, 1);
+    if (status)
+        return status;
+    msleep(150);
+    return status;
+}
+
+static int ili9341_send_command(struct device_data *dev_data, u8 *buff, size_t len)
+{
+    gpiod_set_value(dev_data->dc_gpio, ILI9341_DC_COMMAND);
+    return spi_write(dev_data->client, buff, len);
+}
+
+static int ili9341_send_command_with_args(struct device_data *dev_data, u8 cmd, u8 *args, size_t args_len)
+{
+    int status;
+    status = ili9341_send_command(dev_data, &cmd, 1);
+    if (status)
+        return status;
+    status = ili9341_send_data(dev_data, args, args_len);
+    return status;
+}
+
+static int ili9341_send_data(struct device_data *dev_data, u8 *buff, size_t len)
+{
+    gpiod_set_value(dev_data->dc_gpio, ILI9341_DC_DATA);
+    return spi_write(dev_data->client, buff, len);
+}
+
+static int ili9341_send_display_buff_dma(struct device_data *dev_data)
+{
+    struct spi_message buff_message;
+    struct spi_transfer buff_transfer;
+
+    spi_message_init(&buff_message);
+    buff_message.is_dma_mapped = 1;
+    buff_transfer.tx_buf = dev_data->display_buff;
+    buff_transfer.len = ILI9341_BUFFER_SIZE;
+    buff_transfer.tx_dma = dev_data->dma_display_buff;
+
+    spi_message_add_tail(&buff_transfer, &buff_message);
+    gpiod_set_value(dev_data->dc_gpio, ILI9341_DC_DATA);
+    return spi_sync(dev_data->client, &buff_message);
+}
+
+// int ili9341_set_window(struct device_data *dev_data)
+// {
+//     u8 caset[] = {0x00, 0x00, (ILI9341_HEIGHT - 1) >> 8, (ILI9341_HEIGHT - 1) & 0xFF}; // 0x00, 0x00, 0x00, 0xEF (0–239 for logical Y)
+//     u8 paset[] = {0x00, 0x00, (ILI9341_WIDTH - 1) >> 8, (ILI9341_WIDTH - 1) & 0xFF};  // 0x00, 0x00, 0x01, 0x3F (0–319 for logical X)
+//     int status;
+
+//     status = ili9341_send_command_with_args(dev_data, ILI9341_CASET, caset, sizeof(caset));
+//     if (status) return status;
+
+//     status = ili9341_send_command_with_args(dev_data, ILI9341_PASET, paset, sizeof(paset));
+//     return status;
+// }
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/display.h b/drivers/video/fbdev/ili9341_cus/display.h
new file mode 100644
index 000000000000..c5c3024d68a1
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/display.h
@@ -0,0 +1,25 @@
+#ifndef _ILI9341_DISPLAY_H
+#define _ILI9341_DISPLAY_H
+
+#include <linux/types.h>
+
+#include "ili9341.h"
+
+#define ILI9341_HEIGHT              240
+#define ILI9341_WIDTH               320
+#define ILI9341_BYTES_PER_PIXEL     2
+#define ILI9341_BITS_PER_PIXEL      (8 * ILI9341_BYTES_PER_PIXEL)
+#define ILI9341_COLOR_LENGTH_RED_BLUE 5
+#define ILI9341_COLOR_LENGTH_GREEN  6
+#define ILI9341_BUFFER_SIZE         (ILI9341_HEIGHT * ILI9341_WIDTH * ILI9341_BYTES_PER_PIXEL)
+#define ILI9341_LINE_LENGTH         (ILI9341_WIDTH * ILI9341_BYTES_PER_PIXEL)
+
+#define ILI9341_RED_OFFSET          11
+#define ILI9341_GREEN_OFFSET        5
+#define ILI9341_BLUE_OFFSET         0
+
+int ili9341_init(struct device_data *dev_data);
+int ili9341_send_display_buff(struct device_data *dev_data);
+// int ili9341_set_window(struct device_data *dev_data);
+
+#endif /* _ILI9341_DISPLAY_H */
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/ili9341.c b/drivers/video/fbdev/ili9341_cus/ili9341.c
new file mode 100644
index 000000000000..19e08f82df87
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/ili9341.c
@@ -0,0 +1,270 @@
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+#include <asm/page.h>
+
+#include "ili9341.h"
+#include "display.h"
+
+static int display_thread(void *data);
+static int ili9341_probe(struct spi_device *client);
+static int ili9341_remove(struct spi_device *client);
+static int ili9341_try_configure_dma(struct device_data *dev_data);
+static int ili9341_setcolreg(unsigned regno, unsigned red, unsigned green,
+                             unsigned blue, unsigned transp, struct fb_info *info);
+static int ili9341_check_var(struct fb_var_screeninfo *var, struct fb_info *info);
+static void ili9341_configure_fb(struct device_data *dev_data);
+
+static struct of_device_id ili9341_driver_of_ids[] = {
+    {
+        .compatible = "mr,custom_ili9341",
+    },
+    {/* NULL */},
+};
+MODULE_DEVICE_TABLE(of, ili9341_driver_of_ids);
+
+static struct spi_device_id ili9341_ids[] = {
+    {"custom_ili9341", 0},
+    {/* NULL */},
+};
+MODULE_DEVICE_TABLE(spi, ili9341_ids);
+
+static struct spi_driver ili9341_spi_driver = {
+    .probe = ili9341_probe,
+    .remove = ili9341_remove,
+    .driver = {
+        .name = "custom_ili9341",
+        .of_match_table = of_match_ptr(ili9341_driver_of_ids),
+    },
+};
+
+static struct fb_ops ili9341_fb_ops = {
+    .owner = THIS_MODULE,
+    .fb_check_var = ili9341_check_var,
+    .fb_setcolreg = ili9341_setcolreg,
+    .fb_fillrect = cfb_fillrect,
+    .fb_imageblit = cfb_imageblit,
+    .fb_copyarea = cfb_copyarea,
+};
+
+static int display_thread(void *data)
+{
+    struct device_data *dev_data;
+    dev_data = data;
+
+    while (!kthread_should_stop())
+    {
+        if (ili9341_send_display_buff(dev_data))
+            dev_err(&dev_data->client->dev, "error occured while sending data to the display");
+    }
+    return 0;
+}
+
+static int ili9341_probe(struct spi_device *client)
+{
+    int status;
+    struct device_data *dev_data;
+
+    if (!device_property_present(&client->dev, "dc-gpios"))
+    {
+        dev_err(&client->dev, "device tree property dc-gpios does not exist\n");
+        return -EINVAL;
+    }
+
+    dev_data = devm_kzalloc(&client->dev, sizeof(struct device_data), GFP_KERNEL);
+    if (!dev_data)
+        return -ENOMEM;
+
+    spi_set_drvdata(client, dev_data);
+    dev_data->client = client;
+
+    dev_data->display_buff = devm_kzalloc(&client->dev, ILI9341_BUFFER_SIZE, GFP_KERNEL | GFP_DMA);
+    if (!dev_data->display_buff)
+            return -ENOMEM;
+
+    if (ili9341_try_configure_dma(dev_data))
+    {
+        dev_data->dma_support = false;
+        dev_info(&client->dev, "DMA not supported\n");
+    }
+    else
+    {
+        dev_data->dma_support = true;
+        dev_info(&client->dev, "using DMA\n");
+    }
+
+    dev_data->dc_gpio = gpiod_get(&client->dev, "dc", GPIOD_OUT_HIGH);
+    if (IS_ERR(dev_data->dc_gpio))
+    {
+        dev_err(&client->dev, "could not setup dc gpio\n");
+        return PTR_ERR(dev_data->dc_gpio);
+    }
+
+    status = ili9341_init(dev_data);
+    if (status)
+    {
+        gpiod_put(dev_data->dc_gpio);
+        dev_err(&client->dev, "error while initialising display hardware\n");
+        return status;
+    }
+
+    dev_data->framebuffer_info = framebuffer_alloc(0, &client->dev);
+    if (dev_data->framebuffer_info == NULL)
+    {
+        gpiod_put(dev_data->dc_gpio);
+        return -ENOMEM;
+    }
+    if (fb_alloc_cmap(&dev_data->framebuffer_info->cmap, ILI9341_BITS_PER_PIXEL, 0))
+    {
+        gpiod_put(dev_data->dc_gpio);
+        framebuffer_release(dev_data->framebuffer_info);
+        return -ENOMEM;
+    }
+
+    ili9341_configure_fb(dev_data);
+
+    if (register_framebuffer(dev_data->framebuffer_info))
+    {
+        fb_dealloc_cmap(&dev_data->framebuffer_info->cmap);
+        framebuffer_release(dev_data->framebuffer_info);
+        gpiod_put(dev_data->dc_gpio);
+        dev_err(&client->dev, "error while registering framebuffer\n");
+        return -EINVAL;
+    }
+
+    dev_data->display_thread = kthread_create(display_thread, dev_data, "ili9341_kthread");
+    if (!dev_data->display_thread)
+    {
+        fb_dealloc_cmap(&dev_data->framebuffer_info->cmap);
+        framebuffer_release(dev_data->framebuffer_info);
+        gpiod_put(dev_data->dc_gpio);
+        return -ECHILD;
+    }
+
+    wake_up_process(dev_data->display_thread);
+    dev_info(&client->dev, "probe successful\n");
+    return 0;
+}
+
+static int ili9341_remove(struct spi_device *client)
+{
+    struct device_data *dev_data;
+    dev_data = spi_get_drvdata(client);
+
+    kthread_stop(dev_data->display_thread);
+    gpiod_put(dev_data->dc_gpio);
+    unregister_framebuffer(dev_data->framebuffer_info);
+    fb_dealloc_cmap(&dev_data->framebuffer_info->cmap);
+    framebuffer_release(dev_data->framebuffer_info);
+    if (dev_data->dma_support)
+        dma_unmap_single(dev_data->dma_dev, dev_data->dma_display_buff, ILI9341_BUFFER_SIZE, DMA_TO_DEVICE);
+    dev_info(&client->dev, "device removed\n");
+    return 0;
+}
+
+static int ili9341_try_configure_dma(struct device_data *dev_data)
+{
+    int status;
+    struct device *dev;
+    status = 0;
+    dev = dev_data->client->master->dev.parent;
+    dev_data->dma_dev = dev;
+
+    if (!dev->dma_mask)
+		return 0;
+
+    dev_data->dma_display_buff = dma_map_single(dev, dev_data->display_buff, ILI9341_BUFFER_SIZE, DMA_TO_DEVICE);
+    status = dma_mapping_error(dev, dev_data->dma_display_buff);
+    return status;
+}
+
+static int ili9341_setcolreg(unsigned regno, unsigned red, unsigned green,
+                             unsigned blue, unsigned transp, struct fb_info *info)
+{
+    if (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < ILI9341_PSEUDO_PALETTE_SIZE)
+    {
+    ((u32 *)(info->pseudo_palette))[regno] =
+    ((red & 0x1F) << ILI9341_RED_OFFSET) | ((green & 0x3F) << ILI9341_GREEN_OFFSET) | ((blue & 0x1F) << ILI9341_BLUE_OFFSET);
+    return 0;
+    }
+    return -EINVAL;
+}
+
+static int ili9341_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    var->xres = ILI9341_WIDTH;
+    var->yres = ILI9341_HEIGHT;
+    var->xres_virtual = ILI9341_WIDTH;
+    var->yres_virtual = ILI9341_HEIGHT;
+    var->bits_per_pixel = ILI9341_BITS_PER_PIXEL;
+    var->grayscale = 0;
+
+    var->red.offset = ILI9341_RED_OFFSET;
+    var->red.length = ILI9341_COLOR_LENGTH_RED_BLUE;
+    var->red.msb_right = 0;
+
+    var->green.offset = ILI9341_GREEN_OFFSET;
+    var->green.length = ILI9341_COLOR_LENGTH_GREEN;
+    var->green.msb_right = 0;
+
+    var->blue.offset = ILI9341_BLUE_OFFSET;
+    var->blue.length = ILI9341_COLOR_LENGTH_RED_BLUE;
+    var->blue.msb_right = 0;
+
+    var->transp.offset = 0;
+    var->transp.length = 0;
+    var->transp.msb_right = 0;
+    return 0;
+}
+
+static void ili9341_configure_fb(struct device_data *dev_data)
+{
+    struct fb_info *info;
+
+    info = dev_data->framebuffer_info;
+    info->screen_base = dev_data->display_buff;
+    info->screen_size = ILI9341_BUFFER_SIZE;
+    info->fbops = &ili9341_fb_ops;
+    info->pseudo_palette = dev_data->pseudo_palette;
+
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.type = FB_TYPE_PACKED_PIXELS;
+    info->fix.line_length = ILI9341_LINE_LENGTH;
+    info->fix.accel = FB_ACCEL_NONE;
+    info->fix.smem_start = __pa(dev_data->display_buff);
+    info->fix.smem_len = ILI9341_BUFFER_SIZE;
+    sprintf(info->fix.id, "CUST_ILI9341");
+
+    info->var.xres = ILI9341_WIDTH;
+    info->var.yres = ILI9341_HEIGHT;
+    info->var.xres_virtual = ILI9341_WIDTH;
+    info->var.yres_virtual = ILI9341_HEIGHT;
+    info->var.bits_per_pixel = ILI9341_BITS_PER_PIXEL;
+    info->var.grayscale = 0;
+    info->var.activate = FB_ACTIVATE_NOW;
+
+    info->var.red.offset = ILI9341_RED_OFFSET;
+    info->var.red.length = ILI9341_COLOR_LENGTH_RED_BLUE;
+    info->var.red.msb_right = 0;
+
+    info->var.green.offset = ILI9341_GREEN_OFFSET;
+    info->var.green.length = ILI9341_COLOR_LENGTH_GREEN;
+    info->var.green.msb_right = 0;
+
+    info->var.blue.offset = ILI9341_BLUE_OFFSET;
+    info->var.blue.length = ILI9341_COLOR_LENGTH_RED_BLUE;
+    info->var.blue.msb_right = 0;
+
+    info->var.transp.offset = 0;
+    info->var.transp.length = 0;
+    info->var.transp.msb_right = 0;
+}
+
+module_spi_driver(ili9341_spi_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hanli");
+MODULE_DESCRIPTION("SPI driver for ILI9341 display");
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/ili9341.h b/drivers/video/fbdev/ili9341_cus/ili9341.h
new file mode 100644
index 000000000000..7d92fc633d93
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/ili9341.h
@@ -0,0 +1,28 @@
+#ifndef _ILI9341_H
+#define _ILI9341_H
+
+#include <linux/types.h>
+#include <linux/kthread.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio/consumer.h>
+#include <linux/dma-mapping.h>
+#include <linux/fb.h>
+
+#define ILI9341_PSEUDO_PALETTE_SIZE 16
+
+struct device_data
+{
+    struct spi_device *client;
+    struct task_struct *display_thread;
+    struct gpio_desc *dc_gpio;
+    u32 pseudo_palette[ILI9341_PSEUDO_PALETTE_SIZE];
+    u8 *display_buff;
+    struct fb_info *framebuffer_info;
+
+    /* underlying DMA-aware controller */
+	struct device *dma_dev;
+    dma_addr_t dma_display_buff;
+    bool dma_support;
+};
+
+#endif /* _ILI9341_H */
\ No newline at end of file
diff --git a/drivers/video/fbdev/ili9341_cus/memory.h b/drivers/video/fbdev/ili9341_cus/memory.h
new file mode 100644
index 000000000000..591b6c1d90ff
--- /dev/null
+++ b/drivers/video/fbdev/ili9341_cus/memory.h
@@ -0,0 +1,50 @@
+#ifndef _ILI9341_MEMORY_H
+#define _ILI9341_MEMORY_H
+
+#define ILI9341_NOP           0x00
+#define ILI9341_SWRESET       0x01
+#define ILI9341_RDDID         0x04
+#define ILI9341_RDDST         0x09
+#define ILI9341_SLPIN         0x10
+#define ILI9341_SLPOUT        0x11
+#define ILI9341_PTLON         0x12
+#define ILI9341_NORON         0x13
+#define ILI9341_RDMODE        0x0A
+#define ILI9341_RDMADCTL      0x0B
+#define ILI9341_RDPIXFMT      0x0C
+#define ILI9341_RDIMGFMT      0x0D
+#define ILI9341_RDSELFDIAG    0x0F
+#define ILI9341_INVOFF        0x20
+#define ILI9341_INVON         0x21
+#define ILI9341_GAMMASET      0x26
+#define ILI9341_DISPOFF       0x28
+#define ILI9341_DISPON        0x29
+#define ILI9341_CASET         0x2A
+#define ILI9341_PASET         0x2B
+#define ILI9341_RAMWR         0x2C
+#define ILI9341_RAMRD         0x2E
+#define ILI9341_PTLAR         0x30
+#define ILI9341_VSCRDEF       0x33
+#define ILI9341_MADCTL        0x36
+#define ILI9341_VSCRSADD      0x37
+#define ILI9341_PIXFMT        0x3A
+#define ILI9341_FRMCTR1       0xB1
+#define ILI9341_FRMCTR2       0xB2
+#define ILI9341_FRMCTR3       0xB3
+#define ILI9341_INVCTR        0xB4
+#define ILI9341_DFUNCTR       0xB6
+#define ILI9341_PWCTR1        0xC0
+#define ILI9341_PWCTR2        0xC1
+#define ILI9341_PWCTR3        0xC2
+#define ILI9341_PWCTR4        0xC3
+#define ILI9341_PWCTR5        0xC4
+#define ILI9341_VMCTR1        0xC5
+#define ILI9341_VMCTR2        0xC7
+#define ILI9341_RDID1         0xDA
+#define ILI9341_RDID2         0xDB
+#define ILI9341_RDID3         0xDC
+#define ILI9341_RDID4         0xDD
+#define ILI9341_GMCTRP1       0xE0
+#define ILI9341_GMCTRN1       0xE1
+
+#endif /* _ILI9341_MEMORY_H */
\ No newline at end of file
-- 
2.34.1

